"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = createCorePlugin;

var _immutable = require("immutable");

var _immutable2 = _interopRequireDefault(_immutable);

var _draftJs = require("draft-js");

var _notFound = require("./atomicBlocks/not-found");

var _notFound2 = _interopRequireDefault(_notFound);

var _Media = require("./components/Media");

var _Media2 = _interopRequireDefault(_Media);

var _utils = require("./utils");

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

var NO_RESET_STYLE_DEFAULT = ["ordered-list-item", "unordered-list-item"]; /*
                                                                            * Copyright (c) 2016, Globo.com (https://github.com/globocom)
                                                                            *
                                                                            * License: MIT
                                                                            */

function createCorePlugin() {
  var config = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};

  var PluginFunctions = void 0;
  var getProps = void 0;
  var setEditorState = void 0;
  var getEditorState = void 0;
  var getReadOnly = void 0;
  var setReadOnly = void 0;

  return {
    initialize: function initialize(_PluginFunctions) {
      PluginFunctions = _PluginFunctions;
      var _PluginFunctions2 = PluginFunctions;
      getProps = _PluginFunctions2.getProps;
      setEditorState = _PluginFunctions2.setEditorState;
      getEditorState = _PluginFunctions2.getEditorState;
      getReadOnly = _PluginFunctions2.getReadOnly;
      setReadOnly = _PluginFunctions2.setReadOnly;
    },
    getAtomicBlocksByType: function getAtomicBlocksByType(atomicBlocks) {
      return atomicBlocks.reduce(function (atomicBlocksByType, atomicBlock) {
        atomicBlocksByType[atomicBlock.type] = atomicBlock;
        return atomicBlocksByType;
      }, {});
    },
    blockRendererFn: function blockRendererFn(contentBlock) {
      if (contentBlock.getType() !== "atomic") {
        return null;
      }

      var type = contentBlock.getData().toObject().type;

      var _getProps = getProps(),
          atomicBlocks = _getProps.atomicBlocks;

      var atomicBlocksByType = this.getAtomicBlocksByType(atomicBlocks);
      var atomicBlock = atomicBlocksByType[type] || this.handleBlockNotFound(contentBlock, PluginFunctions);
      if (!atomicBlock) {
        return null;
      }

      return {
        component: _Media2.default,
        editable: false,
        props: {
          atomicBlock: atomicBlock,
          get plugin() {
            (0, _utils.warnOnce)("Megadraft will remove `blockProps.plugin` prop in future versions, please use `blockProps.atomicBlock` instead");
            return atomicBlock;
          },
          get editorState() {
            (0, _utils.warnOnce)("Megadraft will remove `blockProps.editorState` prop in future versions, please use `blockProps.getEditorState` instead");
            return getEditorState();
          },
          getEditorState: getEditorState,
          setEditorState: setEditorState,
          // TODO: make atomicBlocks use setEditorState instead of onChange
          onChange: setEditorState,
          setReadOnly: setReadOnly,
          getReadOnly: getReadOnly,
          // TODO: check support for setInitialReadOnly
          getInitialReadOnly: this.getInitialReadOnly,
          setInitialReadOnly: this.setInitialReadOnly
        }
      };
    },
    handleBlockNotFound: function handleBlockNotFound(contentBlock) {
      var _getProps2 = getProps(),
          handleBlockNotFound = _getProps2.handleBlockNotFound;

      if (handleBlockNotFound) {
        return handleBlockNotFound(contentBlock);
      }
      return _notFound2.default;
    },
    blockStyleFn: function blockStyleFn(contentBlock) {
      var type = contentBlock.getType();
      if (type === "unstyled") {
        return "paragraph";
      }
    },
    keyBindingFn: function keyBindingFn(event) {
      var _getProps3 = getProps(),
          _getProps3$keyBinding = _getProps3.keyBindings,
          keyBindings = _getProps3$keyBinding === undefined ? [] : _getProps3$keyBinding;

      var _iteratorNormalCompletion = true;
      var _didIteratorError = false;
      var _iteratorError = undefined;

      try {

        for (var _iterator = keyBindings[Symbol.iterator](), _step; !(_iteratorNormalCompletion = (_step = _iterator.next()).done); _iteratorNormalCompletion = true) {
          var kb = _step.value;

          if (kb.isKeyBound(event)) {
            return kb.name;
          }
        }
      } catch (err) {
        _didIteratorError = true;
        _iteratorError = err;
      } finally {
        try {
          if (!_iteratorNormalCompletion && _iterator.return) {
            _iterator.return();
          }
        } finally {
          if (_didIteratorError) {
            throw _iteratorError;
          }
        }
      }

      return (0, _draftJs.getDefaultKeyBinding)(event);
    },
    handleKeyCommand: function handleKeyCommand(command) {
      var _getProps4 = getProps(),
          _getProps4$keyBinding = _getProps4.keyBindings,
          keyBindings = _getProps4$keyBinding === undefined ? [] : _getProps4$keyBinding;

      // external key bindings


      if (keyBindings.length) {
        var extKb = keyBindings.find(function (kb) {
          return kb.name === command;
        });
        if (extKb) {
          extKb.action();
          return "handled";
        }
      }

      var newState = _draftJs.RichUtils.handleKeyCommand(getEditorState(), command);
      if (newState) {
        setEditorState(newState);
        return "handled";
      }

      return "not-handled";
    },


    /*
    * Copyright (c) 2016 Icelab
    *
    * License: MIT
    */
    //Based on https://github.com/icelab/draft-js-block-breakout-plugin
    resetBlockStyle: function resetBlockStyle(editorState, selection, contentState, currentBlock, blockType) {
      var List = _immutable2.default.List;

      var emptyBlockKey = (0, _draftJs.genKey)();

      var emptyBlock = new _draftJs.ContentBlock({
        key: emptyBlockKey,
        text: "",
        type: blockType,
        depth: 0,
        characterList: List(),
        inlineStyleRanges: []
      });
      var blockMap = contentState.getBlockMap();

      var blocksBefore = blockMap.toSeq().takeUntil(function (v) {
        return v === currentBlock;
      });
      var blocksAfter = blockMap.toSeq().skipUntil(function (v) {
        return v === currentBlock;
      }).rest();

      var augmentedBlocks = [[currentBlock.getKey(), currentBlock], [emptyBlockKey, emptyBlock]];

      var focusKey = emptyBlockKey;
      var newBlocks = blocksBefore.concat(augmentedBlocks, blocksAfter).toOrderedMap();
      var newContentState = contentState.merge({
        blockMap: newBlocks,
        selectionBefore: selection,
        selectionAfter: selection.merge({
          anchorKey: focusKey,
          anchorOffset: 0,
          focusKey: focusKey,
          focusOffset: 0,
          isBackward: false
        })
      });

      var noStyle = _immutable2.default.OrderedSet([]);
      var resetState = _draftJs.EditorState.push(editorState, newContentState, "split-block");
      var emptySelection = _draftJs.SelectionState.createEmpty(emptyBlockKey);
      var editorSelected = _draftJs.EditorState.forceSelection(resetState, emptySelection);
      var noStyleState = _draftJs.EditorState.setInlineStyleOverride(editorSelected, noStyle);
      setEditorState(noStyleState);
    },
    handleReturn: function handleReturn(event) {
      var editorState = getEditorState();
      var props = getProps();

      if (props.softNewLines === false) {
        return "not-handled";
      }

      if (!event.shiftKey) {
        var selection = editorState.getSelection();
        var contentState = editorState.getCurrentContent();
        var currentBlock = contentState.getBlockForKey(selection.getEndKey());
        var endOffset = selection.getEndOffset();
        var atEndOfBlock = endOffset === currentBlock.getLength();
        var resetStyleNewLine = props.resetStyleNewLine;
        var blocksWithoutStyleReset = props.blocksWithoutStyleReset || NO_RESET_STYLE_DEFAULT;
        var noReset = blocksWithoutStyleReset.includes(currentBlock.type);

        if (atEndOfBlock && resetStyleNewLine) {
          var blockType = noReset ? currentBlock.type : "unstyled";
          this.resetBlockStyle(editorState, selection, contentState, currentBlock, blockType);
          return "handled";
        }
        return "not-handled";
      }

      var currentContent = editorState.getCurrentContent();
      var currentSelection = editorState.getSelection();
      var contentBlock = currentContent.getBlockMap().get(currentSelection.getFocusKey());
      var contentText = contentBlock.getText();

      if (contentText.charAt(currentSelection.focusOffset - 1) == "\n" || contentText.charAt(currentSelection.focusOffset) == "\n") {
        return "not-handled";
      }

      var newState = _draftJs.RichUtils.insertSoftNewline(editorState);
      setEditorState(newState);
      return "handled";
    },
    onTab: function onTab(event) {
      event.preventDefault();
    }
  };
}